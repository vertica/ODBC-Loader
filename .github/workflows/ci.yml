name: CI

on:
  push:
  pull_request:
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest

    env:
      KIND_CLUSTER: vertica-ci
      KIND_NODE_IMAGE: kindest/node:v1.29.0
      VERTICA_IMAGE: vertica-odbc:ci

    steps:
      - uses: actions/checkout@v3

      - name: Set up MySQL server
        run: |
          docker run -d -p 3306:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=yes --name test-mysql mysql:8.0
          echo "MySQL startup ..."
          until docker exec test-mysql mysql -u root -e "SELECT 1;"; do \
            echo "..."; \
            sleep 1; \
          done;
          docker exec -u root test-mysql mysql -u root -e "CREATE DATABASE testdb;"
          docker exec -u root test-mysql mysql -u root testdb -e "CREATE TABLE test_source (i integer, b boolean, f float, v varchar(32), c char(32), lv varchar(9999), bn binary(32), vb varbinary(32), lvb varbinary(9999), d date, t time, ts timestamp null, tz varchar(80), tsz varchar(80), n numeric(20,4));"
          docker exec -u root test-mysql /bin/bash -c "(echo \"INSERT INTO test_source VALUES (null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);\"; for i in \`seq 1 9\`; do echo \"INSERT INTO test_source VALUES (\$i, 1, \$i.5, 'test \$i', 'test \$i', 'test \$i', 'test \$i', 'test \$i', 'test \$i', '\$((\$i+11))00/1/\$i', '4:0\$i', '2038-01-0\$i 03:14:07', '1:2\$i:00', 'June 1, \$((\$i+11))00 03:2\$i EST', '123456.7890');\"; done) | mysql -u root testdb"
          docker exec -u root test-mysql mysql -u root testdb -e "select * from test_source;"

      # ---------------------------
      # Kubernetes (KinD) + Helm setup
      # ---------------------------
      - name: Set up Kubernetes (KinD)
        uses: helm/kind-action@v1.8.0
        with:
          cluster_name: vertica-ci
          node_image: kindest/node:v1.29.0

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.11.3"

      # ---------------------------
      # Build Vertica UDx image
      # ---------------------------
      - name: Build custom Vertica UDx image
        run: |
          cat <<EOF > Dockerfile.udx-builder
          FROM opentext/vertica-k8s:25.3.0-6
          USER root

          # Install DNF plugins and makecache
          RUN dnf -y install dnf-plugins-core && \
              dnf -y makecache && \
              dnf -y install \
                scl-utils \
                gcc-toolset-12-gcc \
                gcc-toolset-12-gcc-c++ \
                gcc-toolset-12-binutils \
                make perl unixODBC-devel && \
              dnf clean all

          # Install required packages
          RUN dnf -y install \
              gcc gcc-c++ make perl unixODBC-devel \
              && dnf clean all

          # Add MySQL repo (EL8) and install ODBC driver only
          RUN dnf -y install https://repo.mysql.com/mysql80-community-release-el8-9.noarch.rpm && \
              dnf -y install mysql-connector-odbc && \
              dnf clean all

          WORKDIR /var/odbc-loader
          USER dbadmin
          EOF

          docker build -t ${{ env.VERTICA_IMAGE }} -f Dockerfile.udx-builder .
          docker tag ${{ env.VERTICA_IMAGE }} docker.io/library/${{ env.VERTICA_IMAGE }}
          kind load docker-image docker.io/library/${{ env.VERTICA_IMAGE }} --name ${{ env.KIND_CLUSTER }}

      - name: Verify custom image loaded into KinD node
        run: |
          set -e
          NODE=vertica-ci-control-plane
          echo "Checking for vertica-odbc image on the runner (docker)"
          if docker images | grep -q vertica-odbc; then
            echo "Found vertica-odbc locally. Proceeding to check Kind node"
          else
            echo "ERROR: vertica-odbc image not found on the runner. Docker build may have failed."
            echo "Run 'docker images | grep vertica-odbc' locally to inspect.";
            docker images || true
            exit 1
          fi

          echo "Checking for vertica-odbc image on Kind node: $NODE (containerd namespace k8s.io)"
          # check containerd k8s.io namespace where kind stores images
          if docker exec "$NODE" ctr -n k8s.io images ls | grep -q vertica-odbc; then
            echo "vertica-odbc found in Kind node containerd (k8s.io namespace)"
          else
            echo "vertica-odbc NOT found in Kind node; attempting to reload the image into KinD"
            kind load docker-image vertica-odbc:ci --name vertica-ci || true
            echo "Listing images on Kind node after reload (ctr -n k8s.io images ls):"
            docker exec "$NODE" ctr -n k8s.io images ls || true
            # final check
            if docker exec "$NODE" ctr -n k8s.io images ls | grep -q vertica-odbc; then
              echo "vertica-odbc loaded successfully into Kind node after retry"
            else
              echo "ERROR: vertica-odbc image still not present on Kind node '$NODE'."
              echo "Kind load may have failed or the control-plane container name differs."
              echo "Available images on Kind node:"
              docker exec "$NODE" ctr -n k8s.io images ls || true
              exit 1
            fi
          fi

      - name: Add Helm repositories
        run: |
          helm repo add vertica-charts https://vertica.github.io/charts
          helm repo add bitnami https://charts.bitnami.com/bitnami || true
          helm repo update

      # ---------------------------
      # MinIO Setup
      # ---------------------------
      - name: Install MinIO
        run: |
          kubectl create ns minio
          cat <<'EOF' > minio.yaml
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: minio
            namespace: minio
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: minio
            template:
              metadata:
                labels:
                  app: minio
              spec:
                containers:
                  - name: minio
                    image: minio/minio:latest
                    args: ["server", "/data"]
                    env:
                      - name: MINIO_ROOT_USER
                        value: "minioadmin"
                      - name: MINIO_ROOT_PASSWORD
                        value: "minioadmin"
                    ports:
                      - containerPort: 9000
                    volumeMounts:
                      - name: data
                        mountPath: /data
                volumes:
                  - name: data
                    emptyDir: {}
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: minio
            namespace: minio
          spec:
            selector:
              app: minio
            ports:
              - port: 9000
                targetPort: 9000
          EOF
          kubectl apply -f minio.yaml
          kubectl -n minio rollout status deployment/minio --timeout=2m
          kubectl get pods -n minio -o wide || true
          kubectl get svc -n minio || true

      - name: Ensure MinIO bucket exists
        run: |
          kubectl run mc-client --rm -i --restart=Never \
            --image=minio/mc:latest \
            -n minio \
            --command -- bash -c "
              mc alias set localminio http://minio.minio.svc.cluster.local:9000 minioadmin minioadmin && \
              mc mb --ignore-existing localminio/vertica-fleeting && \
              mc ls localminio
            "

      - name: Create MinIO Secret
        run: |
          kubectl create ns my-verticadb-operator
          kubectl delete secret communal-creds -n my-verticadb-operator --ignore-not-found
          kubectl create secret generic communal-creds \
            -n my-verticadb-operator \
            --from-literal=accesskey="minioadmin" \
            --from-literal=secretkey="minioadmin"
          kubectl get secret communal-creds -n my-verticadb-operator -o yaml || true

      # ---------------------------
      # Vertica Operator + DB Deployment
      # ---------------------------
      - name: Install Vertica Operator
        run: |
          cat <<'EOF' > operator-values.yaml
          installCRDs: true
          controller:
            extraEnv:
              - name: AWS_REGION
                value: "us-east-1"
              - name: AWS_DEFAULT_REGION
                value: "us-east-1"
            
            imagePullPolicy: IfNotPresent
          EOF
          helm upgrade --install vdb-op vertica-charts/verticadb-operator \
            -n my-verticadb-operator -f operator-values.yaml --wait --timeout 10m
          kubectl -n my-verticadb-operator get pods -o wide || true

          #!/usr/bin/env bash
          set -euo pipefail
          
          NS="my-verticadb-operator"
          STS="verticadb-sample-defaultsubcluster"
          CLUSTER_NAME="vertica-ci"
          IMAGE="vertica-odbc:ci"
          
          echo "Loading local Docker image into KIND..."
          kind load docker-image "$IMAGE" --name "$CLUSTER_NAME"
          
          echo "Applying VerticaDB CR..."
          cat <<EOF | kubectl apply -f -
          apiVersion: vertica.com/v1
          kind: VerticaDB
          metadata:
            name: verticadb-sample
            namespace: $NS
          spec:
            image: $IMAGE
            imagePullPolicy: Never

            dbName: vdb
            initPolicy: Create
            communal:
              path: s3://vertica-fleeting/mkottakota/
              credentialSecret: communal-creds
              endpoint: http://minio.minio.svc.cluster.local:9000
            subclusters:
              - name: defaultsubcluster
                size: 3
          EOF
          
          echo "Waiting for StatefulSet $STS to be created..."
          for i in {1..30}; do
              if kubectl get statefulset "$STS" -n "$NS" &>/dev/null; then
                  echo "StatefulSet $STS exists."
                  break
              fi
              sleep 2
          done
          
          echo "Waiting for Vertica pods to become ready (CI-friendly)..."
          for i in {1..300}; do  # 10 min timeout
              pods=$(kubectl get pods -l app.kubernetes.io/instance=verticadb-sample -n "$NS" -o json)
              not_ready=$(echo "$pods" | jq '.items[] | select(.status.phase != "Running") | .metadata.name')
              error_pods=$(echo "$pods" | jq '.items[] | select(.status.containerStatuses[]?.state.waiting?.reason=="ErrImagePull" or .status.containerStatuses[]?.state.waiting?.reason=="ImagePullBackOff") | .metadata.name')
          
              if [[ -n "$error_pods" ]]; then
                  echo "Error pulling image for pod(s): $error_pods"
                  kubectl get pods -n "$NS"
                  exit 1
              fi
          
              if [[ -z "$not_ready" ]]; then
                  echo "All pods are running!"
                  break
              fi
          
              echo "Pods not ready yet: $not_ready"
              # fetch last 10 lines of logs from all pods for debugging
              for pod in $(echo "$pods" | jq -r '.items[].metadata.name'); do
                  echo "Logs for $pod:"
                  kubectl logs "$pod" -n "$NS" --tail=10 || true
              done
          
              sleep 5
          done
          
          kubectl get pods -n "$NS" -o wide
          
          
      -   name: Debug VerticaDB deployment
          run: |
            NS=my-verticadb-operator
            kubectl describe verticadb verticadb-sample -n "$NS" || true
            kubectl get events -n "$NS" --sort-by=.metadata.creationTimestamp | tail -20 || true
          
      -   name: Wait for Vertica readiness
          run: |
            NS=my-verticadb-operator
            SS=verticadb-sample-defaultsubcluster
            POD=${SS}-0
            for i in {1..30}; do
              kubectl get pod ${POD} -n ${NS} && break || sleep 10
            done
            kubectl wait --for=condition=Ready pod/${POD} -n ${NS} --timeout=5m

      - name: Collect debug info (images & pod)
        if: failure()
        run: |
          set -e
          NODE=vertica-ci-control-plane
          echo "--- Local docker images ---"
          docker images || true
          echo "--- Docker containers (showing kind control-plane candidate names) ---"
          docker ps --format '{{.Names}} {{.Image}}' || true
          echo "--- Inspecting Kind control-plane container: $NODE ---"
          if docker ps --format '{{.Names}}' | grep -q "$NODE"; then
            echo "Found control-plane container $NODE; listing containerd images (k8s.io namespace)"
            docker exec "$NODE" ctr -n k8s.io images ls || true
          else
            echo "Control-plane container '$NODE' not found; listing available containers for debug:"
            docker ps --format '{{.Names}} {{.Image}}' || true
          fi

          echo "--- Kubernetes: Vertica pod describe & recent events ---"
          kubectl -n my-verticadb-operator describe pod verticadb-sample-defaultsubcluster-0 || true
          kubectl -n my-verticadb-operator get events --sort-by=.metadata.creationTimestamp | tail -30 || true

      # ---------------------------
      # Build + Test
      # ---------------------------
      - name: Build UDx with Symlinks
        run: |
          docker run --rm -u root -v $(pwd):/src ${{ env.VERTICA_IMAGE }} bash -c "
            cd /src && 
            
            # 1. Debug: Show where the SDK files actually are
            echo 'Checking SDK location...'
            ls -1 /opt/vertica/sdk/Vertica.cpp || echo 'Vertica.cpp not in /opt/vertica/sdk/'
            
            # 2. Create the directory and symlinks
            mkdir -p /opt/vertica/sdk/include
            ln -sf /opt/vertica/sdk/Vertica.h /opt/vertica/sdk/include/Vertica.h
            ln -sf /opt/vertica/sdk/Vertica.cpp /opt/vertica/sdk/include/Vertica.cpp
            ln -sf /opt/vertica/sdk/VerticaUDx.h /opt/vertica/sdk/include/VerticaUDx.h
            
            # 3. Build
            if [ -f /opt/rh/gcc-toolset-12/enable ]; then
              source /opt/rh/gcc-toolset-12/enable
            fi
            
            make
          "
          
      - name: Copy lib and ddl to Vertica pod
        run: |
          NS=my-verticadb-operator
          kubectl cp lib/ODBCLoader.so "$NS"/verticadb-sample-defaultsubcluster-0:/tmp/lib/ODBCLoader.so -c server -n "$NS"
          kubectl cp ddl/install.sql "$NS"/verticadb-sample-defaultsubcluster-0:/tmp/install.sql -c server -n "$NS"

      - name: Install UDx from Vertica pod
        run: |
          NS=my-verticadb-operator
          kubectl exec -n "$NS" verticadb-sample-defaultsubcluster-0 -c server -- bash -c 'cd /tmp && /opt/vertica/bin/vsql -U dbadmin -d vdb -f install.sql'

      - name: Copy repo to Vertica pod for testing
        run: |
          NS=my-verticadb-operator
          kubectl cp . "$NS"/verticadb-sample-defaultsubcluster-0:/var/odbc-loader -c server

      - name: Run ODBC Loader Tests in Vertica pod
        run: |
          NS=my-verticadb-operator
          SS=verticadb-sample-defaultsubcluster
          POD=${SS}-0
          kubectl exec -n "$NS" ${POD} -c server -- bash -c 'cp /var/odbc-loader/tests/config/odbc.ini /etc/odbc.ini && cp /var/odbc-loader/tests/config/odbcinst.ini /etc/odbcinst.ini && cd /var/odbc-loader && make test'
      
      - name: Teardown resources
        if: always()
        run: |
          set -e
          # Delete the VerticaDB custom resource and wait a short while for cleanup
          kubectl delete verticadb verticadb-sample -n my-verticadb-operator --ignore-not-found || true
          sleep 3
          # Uninstall the operator release (if installed)
          helm uninstall vdb-op -n my-verticadb-operator || true
          # Delete namespaces created for the CI run
          kubectl delete ns my-verticadb-operator --ignore-not-found || true
          kubectl delete ns minio --ignore-not-found || true
          # Stop the local MySQL container used for tests
          docker rm -f test-mysql || true
          # Delete the KinD cluster created for this workflow
          if command -v kind >/dev/null 2>&1; then
            kind delete cluster --name vertica-ci || true
          fi



